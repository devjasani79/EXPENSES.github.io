const mongoose = require("mongoose");
const dotenv = require("dotenv").config();

const connectDb = async () => {
    try {
        const connect = await mongoose.connect(process.env.CONNECTION_STRING);
        console.log(`Database Connected: ${connect.connection.host} (${connect.connection.name})`);
    } catch (err) {
        console.error("Database Connection Error:", err.message);
        process.exit(1); // Exit process with failure
    }
};

module.exports = connectDb;
const Budget = require("../models/budgetModel");
const Expense = require("../models/expenseModel");
const asyncHandler = require("express-async-handler");

// @desc Set or update the budget for the current or specified month
// @route POST /api/budget
// @access Private
const setBudget = asyncHandler(async (req, res) => {
  const { amount, month } = req.body;

  const currentMonth = month || new Date().toISOString().slice(0, 7); // Default to current month
  let budget = await Budget.findOne({ user_id: req.user.id, month: currentMonth });

  // If no budget is found for this month, check the previous month's budget
  if (!budget) {
    const previousMonth = new Date(currentMonth);
    previousMonth.setMonth(previousMonth.getMonth() - 1); // Get previous month
    const previousMonthString = previousMonth.toISOString().slice(0, 7); // Format as YYYY-MM

    // Check for previous month's budget
    const previousBudget = await Budget.findOne({
      user_id: req.user.id,
      month: previousMonthString,
    });

    if (previousBudget) {
      // If previous month budget exists, carry it over
      budget = await Budget.create({
        user_id: req.user.id,
        month: currentMonth,
        amount: previousBudget.amount, // Carry over the same amount
        exceededCount: previousBudget.exceededCount,
        isExceeded: previousBudget.isExceeded,
      });
    } else {
      // No previous budget, create a new one
      budget = await Budget.create({
        user_id: req.user.id,
        month: currentMonth,
        amount,
        exceededCount: 0,
        isExceeded: false,
      });
    }
  } else {
    // Budget exists, update it
    budget.amount = amount;
    await budget.save();
  }

  res.status(200).json({ message: `Budget set for ${currentMonth}`, budget });
});

// @desc Get budget details and tracking
// @route GET /api/budget
// @access Private
const getBudget = asyncHandler(async (req, res) => {
  const month = req.query.month || new Date().toISOString().slice(0, 7);

  const budget = await Budget.findOne({
    user_id: req.user.id,
    month,
  });

  if (!budget) {
    res.status(404);
    throw new Error("Budget not found for this month");
  }

  // Calculate total expenses for the month
  const expenses = await Expense.aggregate([
    {
      $match: {
        user_id: budget.user_id,
        createdAt: {
          $gte: new Date(`${month}-01`),
          $lte: new Date(`${month}-31`),
        },
      },
    },
    {
      $group: {
        _id: null,
        totalSpent: { $sum: "$amount" },
      },
    },
  ]);

  const totalSpent = expenses[0]?.totalSpent || 0;
  const remainingBudget = budget.amount - totalSpent;

  res.status(200).json({
    budget: budget.amount,
    totalSpent,
    remainingBudget,
    isExceeded: totalSpent > budget.amount,
    exceededCount: budget.exceededCount,
  });
});

// @desc Track how many months were within or exceeded the budget
// @route GET /api/budget/track
// @access Private
const trackBudget = asyncHandler(async (req, res) => {
  const budgets = await Budget.find({ user_id: req.user.id });

  // Arrays to store months that exceeded budget, and the exceeded amount details
  const exceededDetails = [];
  let withinBudgetMonths = 0;
  let exceededBudgetMonths = 0;

  for (const budget of budgets) {
    const expenses = await Expense.aggregate([
      {
        $match: {
          user_id: budget.user_id,
          createdAt: {
            $gte: new Date(`${budget.month}-01`),
            $lte: new Date(`${budget.month}-31`),
          },
        },
      },
      {
        $group: {
          _id: null,
          totalSpent: { $sum: "$amount" },
        },
      },
    ]);

    const totalSpent = expenses[0]?.totalSpent || 0;

    if (totalSpent > budget.amount) {
      exceededBudgetMonths += 1;
      exceededDetails.push({
        month: budget.month,
        budget: budget.amount,
        totalSpent,
        exceededAmount: totalSpent - budget.amount,
      });
    } else {
      withinBudgetMonths += 1;
    }
  }

  res.status(200).json({
    totalMonths: budgets.length,
    withinBudgetMonths,
    exceededBudgetMonths,
    exceededDetails, // Provide the detailed months that exceeded the budget
  });
});

module.exports = { setBudget, getBudget, trackBudget };
const asyncHandler = require("express-async-handler");
const Expense = require("../models/expenseModel");
// const { trackExpense } = require('../utils/trackExpenseUtils'); 
// Ensure the path is correct
const { trackExpense } = require('../utils/trackExpenseUtils'); // Ensure correct import

// Your controller code where you use trackExpenseUtils


// @desc Get all expenses for the logged-in user
// @route GET /api/expenses
// @access Private
const getExpenses = asyncHandler(async (req, res) => {
  const expenses = await Expense.find({ user_id: req.user.id });
  res.status(200).json(expenses);
});

// @desc Create a new expense
// @route POST /api/expenses
// @access Private
const createExpense = asyncHandler(async (req, res) => {
  const { amount, category, paymentMethod, description, to } = req.body;

  // Validate required fields
  if (!amount || !category || !paymentMethod) {
    res.status(400);
    throw new Error("Amount, category, and payment method are mandatory");
  }

  const expense = await Expense.create({
    user_id: req.user.id,
    amount,
    category,
    paymentMethod,
    description,
    to,
  });

  res.status(201).json(expense);
});

// @desc Get a single expense by ID
// @route GET /api/expenses/:id
// @access Private
const getExpense = asyncHandler(async (req, res) => {
  const expense = await Expense.findById(req.params.id);

  if (!expense) {
    res.status(404);
    throw new Error("Expense not found");
  }

  // Verify ownership
  if (expense.user_id.toString() !== req.user.id) {
    res.status(403);
    throw new Error("User does not have permission to view this expense");
  }

  res.status(200).json(expense);
});

// @desc Update an expense by ID
// @route PUT /api/expenses/:id
// @access Private
const updateExpense = asyncHandler(async (req, res) => {
  const expense = await Expense.findById(req.params.id);

  if (!expense) {
    res.status(404);
    throw new Error("Expense not found");
  }

  // Verify ownership
  if (expense.user_id.toString() !== req.user.id) {
    res.status(403);
    throw new Error("User does not have permission to update this expense");
  }

  const updatedExpense = await Expense.findByIdAndUpdate(
    req.params.id,
    req.body,
    { new: true } // Return the updated expense
  );

  res.status(200).json(updatedExpense);
});

// @desc Delete an expense by ID
// @route DELETE /api/expenses/:id
// @access Private
const deleteExpense = asyncHandler(async (req, res) => {
  const expense = await Expense.findById(req.params.id);

  if (!expense) {
    res.status(404);
    throw new Error("Expense not found");
  }

  // Verify ownership
  if (expense.user_id.toString() !== req.user.id) {
    res.status(403);
    throw new Error("User does not have permission to delete this expense");
  }

  await Expense.deleteOne({ _id: req.params.id });
  res.status(200).json({ message: "Expense deleted successfully", expense });
});



// @desc Track expenses with dynamic filters
// @route POST /api/expenses/track
// @access Private
const trackExpenses = asyncHandler(async (req, res) => {
  const filters = req.body; // assuming filters are passed in the request body

  if (!req.user || !req.user.id) {
    return res.status(401).json({ message: "Unauthorized access" });
  }

  const expenses = await trackExpense(filters, req.user.id);
  res.status(200).json(expenses);
});


module.exports = {
  getExpenses,
  createExpense,
  getExpense,
  updateExpense,
  deleteExpense,
  trackExpenses,
};
// controllers/statsController.js
const asyncHandler = require("express-async-handler");
const generatePDF = require("../utils/downloadPDF");
const Expense = require("../models/expenseModel");
const mongoose = require("mongoose");
const isValidObjectId = (id) => mongoose.Types.ObjectId.isValid(id);

// Update all the places where you are calling `mongoose.Types.ObjectId()`
const getCategoryStats = asyncHandler(async (req, res) => {
  try {
    const userId = req.user.id;

    // Validate user ID
    if (!isValidObjectId(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }

    const stats = await Expense.aggregate([
      { $match: { user_id: new mongoose.Types.ObjectId(userId) } }, // Use `new mongoose.Types.ObjectId()`
      { $group: { _id: "$category", totalAmount: { $sum: "$amount" } } },
    ]);

    if (!stats || stats.length === 0) {
      return res.status(404).json({ message: "No data found" });
    }

    return res.status(200).json(stats);
  } catch (error) {
    console.error("Error fetching category stats:", error);
    return res.status(500).json({ message: "Server error" });
  }
});

const getMonthlyStats = asyncHandler(async (req, res) => {
  try {
    const userId = req.user.id;

    // Validate user ID
    if (!isValidObjectId(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }

    const stats = await Expense.aggregate([
      { $match: { user_id: new mongoose.Types.ObjectId(userId) } }, // Use `new mongoose.Types.ObjectId()`
      {
        $group: {
          _id: { $month: "$createdAt" }, // Group by month
          total: { $sum: "$amount" },
        },
      },
      { $sort: { "_id": 1 } }, // Sort by month (ascending)
    ]);

    return res.status(200).json(stats);
  } catch (error) {
    console.error("Error fetching monthly stats:", error);
    return res.status(500).json({ message: "Server error" });
  }
});

const getTrends = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      const { period } = req.query; // Get the 'period' query parameter from the request
  
      // Validate user ID
      if (!isValidObjectId(userId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
  
      // Determine the aggregation logic based on the period
      let groupBy;
      switch (period) {
        case "day":
          groupBy = { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } }; // Group by day
          break;
        case "week":
          groupBy = { $isoWeek: "$createdAt" }; // Group by ISO week number
          break;
        case "month":
          groupBy = { $month: "$createdAt" }; // Group by month number
          break;
        case "year":
          groupBy = { $year: "$createdAt" }; // Group by year
          break;
        default:
          return res.status(400).json({ message: "Invalid period parameter" });
      }
  
      const stats = await Expense.aggregate([
        { $match: { user_id: new mongoose.Types.ObjectId(userId) } },
        {
          $group: {
            _id: groupBy,
            total: { $sum: "$amount" },
          },
        },
        { $sort: { "_id": 1 } }, // Sort by the grouping (ascending)
      ]);
  
      return res.status(200).json(stats);
    } catch (error) {
      console.error("Error fetching spending trends:", error);
      return res.status(500).json({ message: "Server error" });
    }
  });
  
const getTopTransactions = asyncHandler(async (req, res) => {
  try {
    const userId = req.user.id;

    // Validate user ID
    if (!isValidObjectId(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }

    const stats = await Expense.find({ user_id: new mongoose.Types.ObjectId(userId) }) // Use `new mongoose.Types.ObjectId()`
      .sort({ amount: -1 }) // Sort by amount descending
      .limit(3); // Limit to top 3 transactions

    if (!stats || stats.length === 0) {
      return res.status(404).json({ message: "No transactions found" });
    }

    return res.status(200).json(stats);
  } catch (error) {
    console.error("Error fetching top transactions:", error);
    return res.status(500).json({ message: "Server error" });
  }
});
// -------------

const downloadExpensesPDF = asyncHandler(async (req, res) => {
    try {
      const userId = req.user.id;
      await generatePDF(userId, res);  // Use the utility function to generate the PDF
    } catch (error) {
      console.error("Error downloading PDF:", error);
      return res.status(500).json({ message: "Server error" });
    }
  });
  
  module.exports = { getCategoryStats, getMonthlyStats, getTrends, getTopTransactions, downloadExpensesPDF };
const asyncHandler = require("express-async-handler");
const bcrypt = require('bcrypt');
const jwt = require("jsonwebtoken");
const User = require("../models/userModel");
const crypto = require('crypto');
const sendEmail = require("../utils/sendEmail");


// Register User
const registerUser  = asyncHandler(async (req, res) => {
  const { username, email, phone, password } = req.body;

  if (!username || !email || !password) {
    res.status(400);
    throw new Error("All fields are mandatory!");
  }

  const emailExists = await User.findOne({ email });
  if (emailExists) {
    res.status(400);
    throw new Error("User  already registered with this email");
  }

  const user = await User.create({
    username,
    email,
    phone,
    password, // Password will be hashed in the pre-save hook
  });

  return res.status(201).json({
    message: "User  registered successfully",
    _id: user.id,
    email: user.email,
    phone: user.phone,
    password: user.password,
  });
});

// Login User
const loginUser  = asyncHandler(async (req, res) => {
  const { email, password } = req.body;

  if (!email || !password) {
    res.status(400);
    throw new Error("All fields are mandatory!");
  }

  const user = await User.findOne({ email });
  if (user && (await bcrypt.compare(password, user.password))) {
    const accessToken = jwt.sign(
      {
        user: {
          username: user.username,
          email: user.email,
          phone: user.phone,
          id: user.id,
        },
      },
      process.env.ACCESS_TOKEN_SECRET,
      { expiresIn: "1h" }
    );

    return res.status(200).json({
      message: "Login successful",
      accessToken,
    });
  } else {
    res.status(401);
    throw new Error("Invalid email or password");
  }
});



// Get current user info (protected route)
const currentUser = asyncHandler(async (req, res) => {
  // Assuming user data is available after validateToken middleware
  const user = await User.findById(req.user.id).select("-password");
  if (!user) {
    res.status(404);
    throw new Error("User not found");
  }

  res.status(200).json({
    message: "User info retrieved successfully",
    user,
  });
});

// Request Password Reset
const requestPasswordReset = asyncHandler(async (req, res) => {
  const { email } = req.body;
  if (!email) return res.status(400).json({ message: "Email is required" });

  const user = await User.findOne({ email });
  if (!user) return res.status(404).json({ message: "User not found" });

  const resetToken = user.generateResetToken();
  await user.save();

  const resetLink = `${process.env.CLIENT_URL}/reset-password/${resetToken}`;
  const message = `Click the link to reset your password: ${resetLink}`;
  await sendEmail({ to: email, subject: "Password Reset", text: message });

  res.status(200).json({ message: "Password reset link sent" });
});

// Reset Password
const resetPassword = asyncHandler(async (req, res) => {
  const { token, password } = req.body;
  if (!token || !password) return res.status(400).json({ message: "Invalid data" });

  const hashedToken = crypto.createHash("sha256").update(token).digest("hex");
  const user = await User.findOne({
    resetToken: hashedToken,
    resetTokenExpires: { $gt: Date.now() },
  });

  if (!user) return res.status(400).json({ message: "Invalid or expired token" });

  // Hash the new password before saving
  user.password = password; // Set the new password
  user.resetToken = undefined;
  user.resetTokenExpires = undefined;
  await user.save();

  res.status(200).json({ message: "Password reset successful" });
});







/**
 * ================================
 * UPDATE USER INFORMATION
 * ================================
 * Allows a user to update their account information.
 * Ensures unique email and phone validation.
 */
const updateUserInfo = asyncHandler(async (req, res) => {
  const userId = req.user.id; // Extract user ID from the validated token
  const { username, email, phone } = req.body;

  const updates = {};
  if (username) updates.username = username;

  // Check for unique email
  if (email) {
    const emailExists = await User.findOne({ email });
    if (emailExists && emailExists.id !== userId) {
      return res.status(400).json({ message: "Email already in use by another user" });
    }
    updates.email = email;
  }

  // Check for unique phone number
  if (phone) {
    const phoneExists = await User.findOne({ phone });
    if (phoneExists && phoneExists.id !== userId) {
      return res.status(400).json({ message: "Phone number already in use by another user" });
    }
    updates.phone = phone;
  }

  // Update the user
  const updatedUser  = await User.findByIdAndUpdate(userId, updates, { new: true }).select("-password");

  if (!updatedUser ) {
    return res.status(404).json({ message: "User  not found" });
  }

  res.status(200).json({
    message: "User  information updated successfully",
    user: updatedUser ,
  });
});


/**
 * ================================
 * DELETE USER ACCOUNT
 * ================================
 * Deletes a user's account from the database.
 */
const deleteUser  = asyncHandler(async (req, res) => {
  const userId = req.user.id; // Extract user ID from the validated token

  // Find and delete the user by their ID
  const user = await User.findByIdAndDelete(userId);

  if (!user) {
    return res.status(404).json({ message: "User  not found" });
  }

  res.status(200).json({ message: "User  account deleted successfully" });
});
module.exports = { registerUser, loginUser,
  requestPasswordReset,
  resetPassword, currentUser,deleteUser,updateUserInfo}
const errorHandler = (err, req, res, next) => {
  const statusCode = res.statusCode || 500;
  const message = err.message || "An unexpected error occurred";

  res.status(statusCode).json({
    message,
    stack: process.env.NODE_ENV === "production" ? null : err.stack,
  });
};
module.exports = errorHandler;const jwt = require("jsonwebtoken");
// const User = require("../models/userModel");

const bcrypt=require('bcrypt')
const validateToken = (req, res, next) => {
  const token = req.headers.authorization?.split(" ")[1]; // Assumes Bearer token format

  if (!token) {
    return res.status(403).json({ message: "Token is required" });
  }

  try {
    const decoded = jwt.verify(token, process.env.ACCESS_TOKEN_SECRET);
    req.user = decoded.user; // Attach user info to request object
    next(); // Proceed to the next middleware or route handler
  } catch (error) {
    res.status(401).json({ message: "Invalid or expired token" });
  }
};

module.exports = validateToken;
const mongoose = require("mongoose");
const moment = require("moment");

const budgetSchema = mongoose.Schema(
  {
    user_id: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      ref: "User", // Reference to the User model
    },
    month: {
      type: String,
      required: true,
      default: moment().format("YYYY-MM"), // Default to current month
    },
    amount: {
      type: Number,
      required: [true, "Please set a budget amount"],
    },
    exceededCount: {
      type: Number,
      default: 0, // Track how many times the budget has been exceeded
    },
    isExceeded: {
      type: Boolean,
      default: false, // Whether the budget is exceeded this month
    },
  },
  {
    timestamps: true,
    toJSON: {
      getters: true, // Enable getters for JSON conversion
    },
  }
);

module.exports = mongoose.model("Budget", budgetSchema);
const mongoose = require("mongoose");
const moment = require("moment");

const expenseSchema = mongoose.Schema(
  {
    user_id: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      ref: "User", // Reference to the User model
    },
    amount: {
      type: Number,
      required: [true, "Please add the expense amount"],
    },
    category: {
      type: String,
      required: [true, "Please add the expense category"],
    },
    paymentMethod: {
      type: String,
      required: [true, "Please select a payment method"],
      enum: ["UPI", "Credit/Debit Cards", "Bank Transfer", "Wallet"], // Predefined payment methods
    },
    description: {
      type: String,
      default: "",
    },
    to: {
      type: String,
      default: "",
    },
  },
  {
    timestamps: true,
    toJSON: {
      getters: true, // Enable getters when converting to JSON
    },
  }
);

// Custom getter for createdAt and updatedAt fields
expenseSchema.path("createdAt").get(function (value) {
  return moment(value).format("YYYY-MM-DD HH:mm:ss"); // Format createdAt
});

expenseSchema.path("updatedAt").get(function (value) {
  return moment(value).format("YYYY-MM-DD HH:mm:ss"); // Format updatedAt
});

module.exports = mongoose.model("Expense", expenseSchema);
const mongoose = require("mongoose");
const crypto = require('crypto');
const bcrypt = require('bcrypt');

const userSchema = mongoose.Schema(
  {
    username: {
      type: String,
      required: [true, "Please add a username"],
    },
    email: {
      type: String,
      required: [true, "Please add an email"],
      unique: true,
      match: [/\S+@\S+\.\S+/, "Please enter a valid email address"],
    },
    phone: {
      type: String,
      required: [true, "Please add a phone number"],
      unique: true,
      match: [/^\d{10}$/, "Please enter a valid 10-digit phone number"],
    },
    password: {
      type: String,
      required: [true, "Please add a password"],
      minlength: 6,
    },
    resetToken: String,
    resetTokenExpires: Date,
  },
  {
    timestamps: true,
  }
);

// Generate password reset token
userSchema.methods.generateResetToken = function () {
  const resetToken = crypto.randomBytes(32).toString("hex");
  this.resetToken = crypto.createHash("sha256").update(resetToken).digest("hex");
  this.resetTokenExpires = Date.now() + 3600000; // 1 hour
  return resetToken;
};

// Hash password before saving
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

module.exports = mongoose.model("User ", userSchema);
const express = require("express");
const router = express.Router();
const validateToken = require("../middleware/validateTokenHandler");
const { setBudget, getBudget, trackBudget } = require("../controllers/budgetController");
const checkAndSendBudgetAlerts = require("../utils/budgetChecker");

// Protect all routes
router.use(validateToken);

router.post("/", setBudget); // Set or update budget
router.get("/", getBudget); // Get current budget details
router.get("/track", trackBudget); // Get tracking stats

router.get("/test-budget-check", async (req, res) => {
    try {
      await checkAndSendBudgetAlerts();
      res.json({ message: "Budget check triggered manually!" });
    } catch (error) {
      res.status(500).json({ error: "Failed to check budget" });
    }
  });
  
module.exports = router;const express = require("express");
const router = express.Router();
const { getExpenses, createExpense, getExpense, updateExpense, deleteExpense, trackExpenses } = require("../controllers/expenseController");
const validateToken = require("../middleware/validateTokenHandler"); // Ensure this is imported

// Define routes with middleware
router.get("/", validateToken, getExpenses); 
router.post("/", validateToken, createExpense);
router.get("/:id", validateToken, getExpense);
router.put("/:id", validateToken, updateExpense);
router.delete("/:id", validateToken, deleteExpense);
router.post("/track", validateToken, trackExpenses);

module.exports = router;const express = require("express");
const validateToken = require("../middleware/validateTokenHandler");
const { getCategoryStats, getMonthlyStats, getTrends, getTopTransactions,downloadExpensesPDF } = require("../controllers/statsController");

const router = express.Router();

router.use(validateToken); // Protect all routes

router.get("/category-wise", getCategoryStats); // Category-wise stats
router.get("/monthly", getMonthlyStats);         // Monthly stats
router.get("/trend", getTrends);                 // Spending trend with period parameter
router.get("/top-transactions", getTopTransactions); // Top 3 highest transactions
router.get("/download/pdf", downloadExpensesPDF);
module.exports = router;const express = require("express");
const { registerUser,
    loginUser,
    currentUser,
    requestPasswordReset,
    resetPassword,
    updateUserInfo,
     deleteUser,
 } = require("../controllers/userController");
const validateToken = require("../middleware/validateTokenHandler");

const router = express.Router();

router.post("/register", registerUser);   // Register user route
router.post("/login", loginUser);         // Login user route
router.get("/current", validateToken, currentUser);  // Protected route to get current user info
router.post("/reset-password-request", requestPasswordReset);
router.post("/reset-password", resetPassword);
router.put("/userinfo", validateToken, updateUserInfo);
router.delete("/userinfo", validateToken, deleteUser);
module.exports = router;CONNECTION_STRING=mongodb+srv://DEVJ79:DEV%40EXPTRK@expensetrk.cz8ek.mongodb.net/
PORT=5001
ACCESS_TOKEN_SECRET=devj123

# SMTP Configuration
SMTP_HOST=smtp.gmail.com          # Gmail's SMTP host
SMTP_PORT=587                     # Common SMTP port for STARTTLS
SMTP_USER=devjasani79@gmail.com # Sender's email address
SMTP_PASS=nljfcatabjqajwpy           # Sender's email app password (use an app password if Gmail)
CLIENT_URL=http://localhost:3000  # Your client-side URL

EMAIL_USER=devjasani79@gmail.com 
EMAIL_PASS=nljfcatabjqajwpy 
const express = require("express");
const dotenv = require("dotenv").config();
const userRoutes = require("./routes/userRoutes");
const expenseRoutes = require("./routes/expenseRoutes"); // Make sure this is properly imported
const statsRoutes = require('./routes/statsRoutes');  // Path to your statsRoutes file
const budgetRoutes = require('./routes/budgetRoutes')
const errorHandler = require("./middleware/errorHandler");
const connectDb = require("./config/dbConnection");


const app = express();

app.use(express.json());  // Parse incoming JSON data

// Use the user routes
app.use("/api/users", userRoutes);
// Use the expense routes here
app.use("/api/expenses", expenseRoutes); 
// Use the stats routes here
app.use('/api/stats', statsRoutes);  
// Use the budget routes here
app.use("/api/budget", budgetRoutes);
// Error handler middleware (optional)
app.use(errorHandler);

// Connect to MongoDB
connectDb(); 


// Import the cron job checker
require("./utils/budgetChecker");



const PORT = process.env.PORT || 5001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
exports.constants = {
    VALIDATION_ERROR: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    SERVER_ERROR: 500,
};const express = require("express");
const router = express.Router();
const validateToken = require("../middleware/validateTokenHandler");
const { setBudget, getBudget, trackBudget } = require("../controllers/budgetController");
const checkAndSendBudgetAlerts = require("../utils/budgetChecker");

// Protect all routes
router.use(validateToken);

router.post("/", setBudget); // Set or update budget
router.get("/", getBudget); // Get current budget details
router.get("/track", trackBudget); // Get tracking stats

router.get("/test-budget-check", async (req, res) => {
    try {
      await checkAndSendBudgetAlerts();
      res.json({ message: "Budget check triggered manually!" });
    } catch (error) {
      res.status(500).json({ error: "Failed to check budget" });
    }
  });
  
module.exports = router;const express = require("express");
const router = express.Router();
const { getExpenses, createExpense, getExpense, updateExpense, deleteExpense, trackExpenses } = require("../controllers/expenseController");
const validateToken = require("../middleware/validateTokenHandler"); // Ensure this is imported

// Define routes with middleware
router.get("/", validateToken, getExpenses); 
router.post("/", validateToken, createExpense);
router.get("/:id", validateToken, getExpense);
router.put("/:id", validateToken, updateExpense);
router.delete("/:id", validateToken, deleteExpense);
router.post("/track", validateToken, trackExpenses);

module.exports = router;const express = require("express");
const validateToken = require("../middleware/validateTokenHandler");
const { getCategoryStats, getMonthlyStats, getTrends, getTopTransactions,downloadExpensesPDF } = require("../controllers/statsController");

const router = express.Router();

router.use(validateToken); // Protect all routes

router.get("/category-wise", getCategoryStats); // Category-wise stats
router.get("/monthly", getMonthlyStats);         // Monthly stats
router.get("/trend", getTrends);                 // Spending trend with period parameter
router.get("/top-transactions", getTopTransactions); // Top 3 highest transactions
router.get("/download/pdf", downloadExpensesPDF);
module.exports = router;
const express = require("express");
const { registerUser,
    loginUser,
    currentUser,
    requestPasswordReset,
    resetPassword,
    updateUserInfo,
     deleteUser,
 } = require("../controllers/userController");
const validateToken = require("../middleware/validateTokenHandler");

const router = express.Router();

router.post("/register", registerUser);   // Register user route
router.post("/login", loginUser);         // Login user route
router.get("/current", validateToken, currentUser);  // Protected route to get current user info
router.post("/reset-password-request", requestPasswordReset);
router.post("/reset-password", resetPassword);
router.put("/userinfo", validateToken, updateUserInfo);
router.delete("/userinfo", validateToken, deleteUser);
module.exports = router;












