const mongoose = require("mongoose");
const dotenv = require("dotenv").config();

const connectDb = async () => {
    try {
        const connect = await mongoose.connect(process.env.CONNECTION_STRING);
        console.log(`Database Connected: ${connect.connection.host} (${connect.connection.name})`);
    } catch (err) {
        console.error("Database Connection Error:", err.message);
        process.exit(1); // Exit process with failure
    }
};

module.exports = connectDb;
const asyncHandler = require("express-async-handler");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const User = require("../models/userModel");
const crypto = require('crypto');
const sendEmail = require("../utils/sendEmail");

// Register User
const registerUser = asyncHandler(async (req, res) => {
  const { username, email, phone, password } = req.body;

  if (!username || !email || !password) {
    res.status(400);
    throw new Error("All fields are mandatory!");
  }

  // Check if email already exists
  const emailExists = await User.findOne({ email });
  if (emailExists) {
    res.status(400);
    throw new Error("User already registered with this email");
  }

  // Phone is optional and should not be unique in this case
  const hashedPassword = await bcrypt.hash(password, 10);

  const user = await User.create({
    username,
    email,
    phone,
    password: hashedPassword,
  });

  if (user) {
    return res.status(201).json({
      message: "User registered successfully",
      _id: user.id,
      email: user.email,
      phone: user.phone,
    });
  } else {
    res.status(400);
    throw new Error("User data is not valid");
  }
});

// Login User
const loginUser = asyncHandler(async (req, res) => {
  const { email, password } = req.body;

  if (!email || !password) {
    res.status(400);
    throw new Error("All fields are mandatory!");
  }

  const user = await User.findOne({ email });
  if (user && (await bcrypt.compare(password, user.password))) {
    const accessToken = jwt.sign(
      {
        user: {
          username: user.username,
          email: user.email,
          phone: user.phone, // Added phone to the payload
          id: user.id,
        },
      },
      process.env.ACCESS_TOKEN_SECRET,
      { expiresIn: "1h" }
    );

    return res.status(200).json({
      message: "Login successful",
      accessToken,
    });
  } else {
    res.status(401);
    throw new Error("Invalid email or password");
  }
});

// Get current user info (protected route)
const currentUser = asyncHandler(async (req, res) => {
  // Assuming user data is available after validateToken middleware
  const user = await User.findById(req.user.id).select("-password");
  if (!user) {
    res.status(404);
    throw new Error("User not found");
  }

  res.status(200).json({
    message: "User info retrieved successfully",
    user,
  });
});

// Request Password Reset
const requestPasswordReset = asyncHandler(async (req, res) => {
  const { email } = req.body;
  if (!email) return res.status(400).json({ message: "Email is required" });

  const user = await User.findOne({ email });
  if (!user) return res.status(404).json({ message: "User not found" });

  const resetToken = user.generateResetToken();
  await user.save();

  const resetLink = `${process.env.CLIENT_URL}/reset-password/${resetToken}`;
  const message = `Click the link to reset your password: ${resetLink}`;
  await sendEmail({ to: email, subject: "Password Reset", text: message });

  res.status(200).json({ message: "Password reset link sent" });
});

// Reset Password
const resetPassword = asyncHandler(async (req, res) => {
  const { token, password } = req.body;
  if (!token || !password) return res.status(400).json({ message: "Invalid data" });

  const hashedToken = crypto.createHash("sha256").update(token).digest("hex");
  const user = await User.findOne({
    resetToken: hashedToken,
    resetTokenExpires: { $gt: Date.now() },
  });

  if (!user) return res.status(400).json({ message: "Invalid or expired token" });

  user.password = password;
  user.resetToken = undefined;
  user.resetTokenExpires = undefined;
  await user.save();

  res.status(200).json({ message: "Password reset successful" });
});
module.exports = { registerUser, loginUser,
  requestPasswordReset,
  resetPassword, currentUser };
const errorHandler = (err, req, res, next) => {
  const statusCode = res.statusCode || 500;
  const message = err.message || "An unexpected error occurred";

  res.status(statusCode).json({
    message,
    stack: process.env.NODE_ENV === "production" ? null : err.stack,
  });
};
module.exports = errorHandler;
const jwt = require("jsonwebtoken");
const User = require("../models/userModel");

const validateToken = (req, res, next) => {
  const token = req.headers.authorization?.split(" ")[1]; // Assumes Bearer token format

  if (!token) {
    return res.status(403).json({ message: "Token is required" });
  }

  try {
    const decoded = jwt.verify(token, process.env.ACCESS_TOKEN_SECRET);
    req.user = decoded.user; // Attach user info to request object
    next(); // Proceed to the next middleware or route handler
  } catch (error) {
    res.status(401).json({ message: "Invalid or expired token" });
  }
};

module.exports = validateToken;
const mongoose = require("mongoose");
const crypto = require('crypto');
// const sendEmail = require("../utils/sendEmail");
const userSchema = mongoose.Schema(
  {
    username: {
      type: String,
      required: [true, "Please add a username"],
    },
    email: {
      type: String,
      required: [true, "Please add an email"],
      unique: true,
      match: [/\S+@\S+\.\S+/, "Please enter a valid email address"],
    },
    phone: {
      type: String,
      required: [true, "Please add a phone number"],
      unique: true,
      match: [/^\d{10}$/, "Please enter a valid 10-digit phone number"],
    },
    password: {
      type: String,
      required: [true, "Please add a password"],
      minlength: 6,
    },
    resetToken: String,
    resetTokenExpires: Date,
  },
  {
    timestamps: true,
  }
);

// Generate password reset token
userSchema.methods.generateResetToken = function () {
  const resetToken = crypto.randomBytes(32).toString("hex");
  this.resetToken = crypto.createHash("sha256").update(resetToken).digest("hex");
  this.resetTokenExpires = Date.now() + 3600000; // 1 hour
  return resetToken;
};

module.exports = mongoose.model("User", userSchema);
const express = require("express");
const { registerUser,
    loginUser,
    currentUser,
    requestPasswordReset,
    resetPassword,
    // updateUserInfo,
    // deleteUser,
 } = require("../controllers/userController");
const validateToken = require("../middleware/validateTokenHandler");

const router = express.Router();

router.post("/register", registerUser);   // Register user route
router.post("/login", loginUser);         // Login user route
router.get("/current", validateToken, currentUser);  // Protected route to get current user info
router.post("/reset-password-request", requestPasswordReset);
router.post("/reset-password", resetPassword);
// router.put("/userinfo", validateToken, updateUserInfo);
// router.delete("/userinfo", validateToken, deleteUser);
module.exports = router;
const nodemailer = require("nodemailer");

const sendEmail = async ({ to, subject, html, text }) => {
  try {
    const transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      secure: false,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      },
    });

    const mailOptions = {
      from: `"Expense Tracker" <${process.env.SMTP_USER}>`,
      to,
      subject,
      html: html || `<p>${text || 'Password Reset Link'}</p>`,
    };

    await transporter.sendMail(mailOptions);
    console.log("Email sent successfully");
  } catch (error) {
    console.error("Error sending email:", error.message);
    throw new Error("Failed to send email");
  }
};
module.exports = sendEmail;
const express = require("express");
const dotenv = require("dotenv").config();
const userRoutes = require("./routes/userRoutes");
// const expenseRoutes = require("./routes/expenseRoutes"); 
// Add expense routes
const errorHandler = require("./middleware/errorHandler");
const connectDb = require("./config/dbConnection");  // Import the db connection

const app = express();

app.use(express.json());  // Parse incoming JSON data

// Use the user routes
app.use("/api/users", userRoutes);

const expenseRoutes = require("./routes/expenseRoutes");
app.use("/api/expenses", expenseRoutes);

// Error handler middleware (optional)
app.use(errorHandler);

// Connect to MongoDB
connectDb();  
// Using your custom connection function

const PORT = process.env.PORT || 5001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
exports.constants = {
    VALIDATION_ERROR: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    SERVER_ERROR: 500,
};
CONNECTION_STRING=mongodb+srv://DEVJ79:DEV%40EXPTRK@expensetrk.cz8ek.mongodb.net/
PORT=5001
ACCESS_TOKEN_SECRET=devj123

# SMTP Configuration
SMTP_HOST=smtp.gmail.com          # Gmail's SMTP host
SMTP_PORT=587                     # Common SMTP port for STARTTLS
SMTP_USER=devjasani79@gmail.com # Sender's email address
SMTP_PASS=nljfcatabjqajwpy           # Sender's email app password (use an app password if Gmail)
CLIENT_URL=http://localhost:3000  # Your client-side URL

so the problem lies intial all apis work register login current reset req reset password etc 
the issues is that user can login intially but when he hits reset password the new password which is set is bringing in some issues i guess because with the fresh new password or even old correct password it gives error of invalid password 
so maybe the issue lies somewhere in hashing crypto so something which cause to not save the new password and get it validated and perform logging function 







